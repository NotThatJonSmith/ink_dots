#version 450
layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0) readonly buffer InputBuffer { uint data[]; } inputBuffer;
layout (binding = 1) buffer OutputBuffer { uint data[]; } outputBuffer;
layout (push_constant) uniform readonly PushConstants {
    uint width;
    uint height;
    uint levels;
    float k_ratio;
    float dot_size_factor;
    float edge_threshold;
    float edge_sigma;
    float cmyk_angles[4];
    float cmyk_pitches[4];
} pc;

// channel 0 = r, 1 = g, 2 = b
// Return the levelized channel value between 
float levelized_channel_value(uint pixel, uint channel)
{
    float v0_255 = float((pixel >> channel*8) & 0xFF);
    float v0_1 = float(v0_255) / 255.0;
    float v0_n = round(v0_1 * float(pc.levels -1 ));
    return v0_n / float(pc.levels - 1);
}

// Return the 0-1 blackness of the pixel, after parameterized multiple (k_ratio)
float black_level_of_pixel(vec3 rgb)
{
    return pc.k_ratio * (1.0 - max(max(rgb.r,rgb.g),rgb.b));
}

vec3 levelize(uint pixel)
{
    vec3 rgb = vec3(
        levelized_channel_value(pixel, 0),
        levelized_channel_value(pixel, 1),
        levelized_channel_value(pixel, 2)
    );
    return rgb;
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    if (x >= pc.width || y >= pc.height) return;

    mat2 dot_to_pixel_transforms[4];
    mat2 pixel_to_dot_transforms[4];

    // This is a compromise b/c we're out of push constant space.
    for (int i = 0; i < 4; i++) {
        float angle_rad = pc.cmyk_angles[i] * 3.14159265f / 180.0f;
        float cos_a = cos(angle_rad);
        float sin_a = sin(angle_rad);
        float r = pc.cmyk_pitches[i];
        dot_to_pixel_transforms[i] = mat2(r * cos_a, -r * sin_a, r * sin_a,  r * cos_a);
    }

    for (int i = 0; i < 4; i++) {
        float a = dot_to_pixel_transforms[i][0][0];
        float b = dot_to_pixel_transforms[i][0][1];
        float c = dot_to_pixel_transforms[i][1][0];
        float d = dot_to_pixel_transforms[i][1][1];
        float det = a * d - b * c;
        pixel_to_dot_transforms[i] = mat2(d / det, -b / det,
                                         -c / det, a / det);
    }

    // Get the dot-space coordinates for this pixel in each CMYK grid
    vec2 c_dot_coords = dot_to_pixel_transforms[0] * vec2(float(x), float(y));
    vec2 m_dot_coords = dot_to_pixel_transforms[1] * vec2(float(x), float(y));
    vec2 y_dot_coords = dot_to_pixel_transforms[2] * vec2(float(x), float(y));
    vec2 k_dot_coords = dot_to_pixel_transforms[3] * vec2(float(x), float(y));

    // Round to get the dot-space coordinates of the centers of each CMYK dot we might be within
    vec2 c_dot_center_coords = round(c_dot_coords);
    vec2 m_dot_center_coords = round(m_dot_coords);
    vec2 y_dot_center_coords = round(y_dot_coords);
    vec2 k_dot_center_coords = round(k_dot_coords);

    // Distances from dot centers in dot space
    float c_dot_dist = length(c_dot_coords - c_dot_center_coords);
    float m_dot_dist = length(m_dot_coords - m_dot_center_coords);
    float y_dot_dist = length(y_dot_coords - y_dot_center_coords);
    float k_dot_dist = length(k_dot_coords - k_dot_center_coords);

    // Get the pixel coordinates at the centers of the CMYK dots we might be within
    vec2 c_center_px_coords = clamp(pixel_to_dot_transforms[0]*c_dot_center_coords, vec2(0,0), vec2(pc.width-1,pc.height-1));
    vec2 m_center_px_coords = clamp(pixel_to_dot_transforms[1]*m_dot_center_coords, vec2(0,0), vec2(pc.width-1,pc.height-1));
    vec2 y_center_px_coords = clamp(pixel_to_dot_transforms[2]*y_dot_center_coords, vec2(0,0), vec2(pc.width-1,pc.height-1));
    vec2 k_center_px_coords = clamp(pixel_to_dot_transforms[3]*k_dot_center_coords, vec2(0,0), vec2(pc.width-1,pc.height-1));

    // Get the 1d buffer indices for those pixel coordinates
    uint c_px_idx = uint(c_center_px_coords.y) * pc.width + uint(c_center_px_coords.x);
    uint y_px_idx = uint(y_center_px_coords.y) * pc.width + uint(y_center_px_coords.x);
    uint m_px_idx = uint(m_center_px_coords.y) * pc.width + uint(m_center_px_coords.x);
    uint k_px_idx = uint(k_center_px_coords.y) * pc.width + uint(k_center_px_coords.x);
    
    // sample the image at the other pixel coords at the centers of the dots
    vec3 c_pixel = levelize(inputBuffer.data[c_px_idx]);
    vec3 m_pixel = levelize(inputBuffer.data[m_px_idx]);
    vec3 y_pixel = levelize(inputBuffer.data[y_px_idx]);
    vec3 k_pixel = levelize(inputBuffer.data[k_px_idx]);

    // Convert levelized RGB to levelized CMYK... interpret as the radii of each dot in dot space
    float c_radius = clamp((1.0 - c_pixel.r) - black_level_of_pixel(c_pixel), 0.0, 1.0) * pc.dot_size_factor;
    float m_radius = clamp((1.0 - m_pixel.g) - black_level_of_pixel(m_pixel), 0.0, 1.0) * pc.dot_size_factor;
    float y_radius = clamp((1.0 - y_pixel.b) - black_level_of_pixel(y_pixel), 0.0, 1.0) * pc.dot_size_factor;
    float k_radius = clamp(black_level_of_pixel(k_pixel), 0.0, 1.0) * pc.dot_size_factor;

    // Back to rgb
    k_radius = 0.0; // BUG: For some reason the black circles are checkered, but the colored ones aren't. 0 for now....
    uint final_r = (k_dot_dist < k_radius || c_dot_dist < c_radius) ? 0 : 255;
    uint final_g = (k_dot_dist < k_radius || m_dot_dist < m_radius) ? 0 : 255;
    uint final_b = (k_dot_dist < k_radius || y_dot_dist < y_radius) ? 0 : 255;

    // Gaussian blur - commented out original to put in a separate pass.. this isn't optimal at all
    // int radius = int(ceil(3.0 * pc.edge_sigma)); // BUG? why 3x?
    // float blurred = 0.0;
    // float weight_sum = 0.0;
    // for (int dy = -radius; dy <= radius; dy++) {
    //     for (int dx = -radius; dx <= radius; dx++) {
    //         int sample_x = int(x) + dx;
    //         int sample_y = int(y) + dy;
    //         if (sample_x >= 0 && sample_x < int(pc.width) &&
    //             sample_y >= 0 && sample_y < int(pc.height)) {
    //             uint sample_idx = uint(sample_y) * pc.width + uint(sample_x);
    //             uint sample_pixel = inputBuffer.data[sample_idx];
    //             vec3 sample_rgb = vec3(float((sample_pixel >> 0) & 0xFF), float((sample_pixel >> 8) & 0xFF), float((sample_pixel >> 16) & 0xFF));
    //             float sample_gray = dot(sample_rgb, vec3(0.2989, 0.5870, 0.1140));
    //             float dist_sq = float(dx * dx + dy * dy);
    //             float weight = exp(-dist_sq / (2.0 * pc.edge_sigma * pc.edge_sigma));
    //             blurred += sample_gray * weight;
    //             weight_sum += weight;
    //         }
    //     }
    // }
    // blurred /= weight_sum;
    
    // Sobel edge detection
    float grad_x = 0.0;
    float grad_y = 0.0;
    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            int sample_x = int(x) + dx;
            int sample_y = int(y) + dy;
            if (sample_x >= 0 && sample_x < int(pc.width) && sample_y >= 0 && sample_y < int(pc.height)) {
                // uint sample_idx = uint(sample_y) * pc.width + uint(sample_x);
                // uint sample_pixel = inputBuffer.data[sample_idx];
                // vec3 sample_rgb = vec3(float((sample_pixel >> 0) & 0xFF), float((sample_pixel >> 8) & 0xFF), float((sample_pixel >> 16) & 0xFF));
                // float sample_gray = dot(sample_rgb, vec3(0.2989, 0.5870, 0.1140));
                // This should be a separate pass and the above should sample from the gb image
                int radius = int(ceil(pc.edge_sigma));
                float blurred = 0.0;
                float weight_sum = 0.0;
                for (int dyg = -radius; dyg <= radius; dyg++) {
                    for (int dxg = -radius; dxg <= radius; dxg++) {
                        int sample_xg = int(sample_x) + dxg;
                        int sample_yg = int(sample_y) + dyg;
                        if (sample_xg >= 0 && sample_xg < int(pc.width) &&
                            sample_yg >= 0 && sample_yg < int(pc.height)) {
                            uint sample_idx = uint(sample_yg) * pc.width + uint(sample_xg);
                            uint sample_pixel = inputBuffer.data[sample_idx];
                            vec3 sample_rgb = vec3(float((sample_pixel >> 0) & 0xFF), float((sample_pixel >> 8) & 0xFF), float((sample_pixel >> 16) & 0xFF));
                            float sample_gray = dot(sample_rgb, vec3(0.2989, 0.5870, 0.1140));
                            float dist_sq = float(dx * dx + dy * dy);
                            float weight = exp(-dist_sq / (2.0 * pc.edge_sigma * pc.edge_sigma));
                            blurred += sample_gray * weight;
                            weight_sum += weight;
                        }
                    }
                }
                blurred /= weight_sum;
                float sample_gray = blurred;
                float sobel_x_weight = float(dx) * (abs(dy) == 1 ? 1.0 : 2.0);
                float sobel_y_weight = float(dy) * (abs(dx) == 1 ? 1.0 : 2.0);
                grad_x += sample_gray * sobel_x_weight;
                grad_y += sample_gray * sobel_y_weight;
            }
        }
    }

    float gradient_magnitude = sqrt(grad_x * grad_x + grad_y * grad_y);
    if (gradient_magnitude > pc.edge_threshold*255.0) {
        final_r = 0;
        final_g = 0;
        final_b = 0;
    }
    outputBuffer.data[y * pc.width + x] = final_r | (final_g << 8) | (final_b << 16) | (0xFF << 24);
}
